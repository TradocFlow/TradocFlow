//! TOML File I/O Operations
//! 
//! File I/O operations for reading and writing TOML data structures
//! with proper error handling and validation.

use std::fs;
use std::path::{Path, PathBuf};
use std::io::{self, Write};
use chrono::Utc;
use toml;

use crate::git_integration::toml_data::{
    ProjectData, ChapterData, Result, TomlDataError
};

/// TOML file manager for project and chapter data
#[derive(Debug, Clone)]
pub struct TomlFileManager {
    /// Root directory containing the TOML files
    pub root_path: PathBuf,
}

impl TomlFileManager {
    /// Create a new TOML file manager
    pub fn new<P: AsRef<Path>>(root_path: P) -> Self {
        Self {
            root_path: root_path.as_ref().to_path_buf(),
        }
    }
    
    /// Get the path to the project.toml file
    pub fn project_toml_path(&self) -> PathBuf {
        self.root_path.join("content").join("project.toml")
    }
    
    /// Get the path to a chapter TOML file
    pub fn chapter_toml_path(&self, chapter_number: u32, chapter_slug: &str) -> PathBuf {
        let filename = format!("{chapter_number:02}_{chapter_slug}.toml");
        self.root_path.join("content").join("chapters").join(filename)
    }
    
    /// Get the content directory path
    pub fn content_dir_path(&self) -> PathBuf {
        self.root_path.join("content")
    }
    
    /// Get the chapters directory path
    pub fn chapters_dir_path(&self) -> PathBuf {
        self.content_dir_path().join("chapters")
    }
    
    /// Initialize directory structure for TOML files
    pub fn init_directories(&self) -> io::Result<()> {
        let content_dir = self.content_dir_path();
        let chapters_dir = self.chapters_dir_path();
        let assets_dir = content_dir.join("assets");
        
        fs::create_dir_all(&content_dir)?;
        fs::create_dir_all(&chapters_dir)?;
        fs::create_dir_all(&assets_dir)?;
        
        // Create .gitkeep files to ensure directories are tracked
        let gitkeep_content = "# This file ensures the directory is tracked by Git\n";
        fs::write(chapters_dir.join(".gitkeep"), gitkeep_content)?;
        fs::write(assets_dir.join(".gitkeep"), gitkeep_content)?;
        
        Ok(())
    }
    
    /// Read project data from project.toml
    pub fn read_project(&self) -> Result<ProjectData> {
        let path = self.project_toml_path();
        let content = fs::read_to_string(&path)
            .map_err(|e| TomlDataError::Validation(format!("Failed to read project.toml: {e}")))?;
        
        let project: ProjectData = toml::from_str(&content)?;
        
        // Validate the loaded data
        project.validate()?;
        
        Ok(project)
    }
    
    /// Write project data to project.toml
    pub fn write_project(&self, project_data: &ProjectData) -> Result<()> {
        // Validate before writing
        project_data.validate()?;
        
        let path = self.project_toml_path();
        
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| TomlDataError::Validation(format!("Failed to create directory: {e}")))?;
        }
        
        // Serialize to TOML with pretty formatting
        let toml_content = toml::to_string_pretty(project_data)?;
        
        // Add header comment
        let header = format!(
            "# Project Configuration File\n# Generated by Tradocument Reviewer at {}\n# Do not edit manually - use the application interface\n\n",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
        );
        
        let final_content = format!("{header}{toml_content}");
        
        // Write atomically by writing to temp file first
        let temp_path = path.with_extension("toml.tmp");
        {
            let mut file = fs::File::create(&temp_path)
                .map_err(|e| TomlDataError::Validation(format!("Failed to create temp file: {e}")))?;
            file.write_all(final_content.as_bytes())
                .map_err(|e| TomlDataError::Validation(format!("Failed to write temp file: {e}")))?;
            file.sync_all()
                .map_err(|e| TomlDataError::Validation(format!("Failed to sync temp file: {e}")))?;
        }
        
        // Atomic rename
        fs::rename(&temp_path, &path)
            .map_err(|e| TomlDataError::Validation(format!("Failed to rename temp file: {e}")))?;
        
        Ok(())
    }
    
    /// Read chapter data from chapter TOML file
    pub fn read_chapter(&self, chapter_number: u32, chapter_slug: &str) -> Result<ChapterData> {
        let path = self.chapter_toml_path(chapter_number, chapter_slug);
        let content = fs::read_to_string(&path)
            .map_err(|e| TomlDataError::Validation(format!("Failed to read chapter file {}: {}", path.display(), e)))?;
        
        let chapter: ChapterData = toml::from_str(&content)?;
        
        // Validate the loaded data
        chapter.validate()?;
        
        Ok(chapter)
    }
    
    /// Write chapter data to chapter TOML file
    pub fn write_chapter(&self, chapter_data: &ChapterData) -> Result<()> {
        // Validate before writing
        chapter_data.validate()?;
        
        let path = self.chapter_toml_path(chapter_data.chapter.number, &chapter_data.chapter.slug);
        
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| TomlDataError::Validation(format!("Failed to create directory: {e}")))?;
        }
        
        // Serialize to TOML with pretty formatting
        let toml_content = toml::to_string_pretty(chapter_data)?;
        
        // Add header comment
        let header = format!(
            "# Chapter Data File: {} - {}\n# Generated by Tradocument Reviewer at {}\n# Do not edit manually - use the application interface\n\n",
            chapter_data.chapter.number,
            chapter_data.chapter.slug,
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
        );
        
        let final_content = format!("{header}{toml_content}");
        
        // Write atomically
        let temp_path = path.with_extension("toml.tmp");
        {
            let mut file = fs::File::create(&temp_path)
                .map_err(|e| TomlDataError::Validation(format!("Failed to create temp file: {e}")))?;
            file.write_all(final_content.as_bytes())
                .map_err(|e| TomlDataError::Validation(format!("Failed to write temp file: {e}")))?;
            file.sync_all()
                .map_err(|e| TomlDataError::Validation(format!("Failed to sync temp file: {e}")))?;
        }
        
        // Atomic rename
        fs::rename(&temp_path, &path)
            .map_err(|e| TomlDataError::Validation(format!("Failed to rename temp file: {e}")))?;
        
        Ok(())
    }
    
    /// List all chapter TOML files in the chapters directory
    pub fn list_chapters(&self) -> io::Result<Vec<(u32, String, PathBuf)>> {
        let chapters_dir = self.chapters_dir_path();
        
        if !chapters_dir.exists() {
            return Ok(Vec::new());
        }
        
        let mut chapters = Vec::new();
        
        for entry in fs::read_dir(&chapters_dir)? {
            let entry = entry?;
            let path = entry.path();
            
            if let Some(filename) = path.file_name().and_then(|n| n.to_str()) {
                if filename.ends_with(".toml") && !filename.starts_with('.') {
                    // Parse filename format: XX_chapter-name.toml
                    if let Some((number_str, slug_part)) = filename.strip_suffix(".toml")
                        .and_then(|name| name.split_once('_')) {
                        if let Ok(number) = number_str.parse::<u32>() {
                            chapters.push((number, slug_part.to_string(), path));
                        }
                    }
                }
            }
        }
        
        // Sort by chapter number
        chapters.sort_by_key(|(number, _, _)| *number);
        
        Ok(chapters)
    }
    
    /// Check if a project.toml file exists
    pub fn project_exists(&self) -> bool {
        self.project_toml_path().exists()
    }
    
    /// Check if a chapter TOML file exists
    pub fn chapter_exists(&self, chapter_number: u32, chapter_slug: &str) -> bool {
        self.chapter_toml_path(chapter_number, chapter_slug).exists()
    }
    
    /// Delete a chapter TOML file
    pub fn delete_chapter(&self, chapter_number: u32, chapter_slug: &str) -> io::Result<()> {
        let path = self.chapter_toml_path(chapter_number, chapter_slug);
        if path.exists() {
            fs::remove_file(path)?;
        }
        Ok(())
    }
    
    /// Create a backup of a TOML file
    pub fn backup_file<P: AsRef<Path>>(&self, file_path: P) -> io::Result<PathBuf> {
        let path = file_path.as_ref();
        let backup_path = path.with_extension(format!("toml.backup.{}", 
            Utc::now().format("%Y%m%d_%H%M%S")));
        
        if path.exists() {
            fs::copy(path, &backup_path)?;
        }
        
        Ok(backup_path)
    }
    
    /// Restore a file from backup
    pub fn restore_from_backup<P: AsRef<Path>>(&self, backup_path: P, target_path: P) -> io::Result<()> {
        let backup = backup_path.as_ref();
        let target = target_path.as_ref();
        
        if backup.exists() {
            fs::copy(backup, target)?;
        }
        
        Ok(())
    }
    
    /// Validate all TOML files in the project
    pub fn validate_all(&self) -> Result<ValidationReport> {
        let mut report = ValidationReport::new();
        
        // Validate project file
        if self.project_exists() {
            match self.read_project() {
                Ok(_) => report.valid_files += 1,
                Err(e) => {
                    report.errors.push(format!("project.toml: {e}"));
                    report.invalid_files += 1;
                }
            }
        } else {
            report.warnings.push("project.toml not found".to_string());
        }
        
        // Validate all chapter files
        match self.list_chapters() {
            Ok(chapters) => {
                for (number, slug, _) in chapters {
                    match self.read_chapter(number, &slug) {
                        Ok(_) => report.valid_files += 1,
                        Err(e) => {
                            report.errors.push(format!("{number:02}_{slug}.toml: {e}"));
                            report.invalid_files += 1;
                        }
                    }
                }
            }
            Err(e) => {
                report.errors.push(format!("Failed to list chapters: {e}"));
            }
        }
        
        Ok(report)
    }
    
    /// Get statistics about the TOML files in the project
    pub fn get_statistics(&self) -> io::Result<ProjectStatistics> {
        let mut stats = ProjectStatistics::default();
        
        // Count chapters
        let chapters = self.list_chapters()?;
        stats.total_chapters = chapters.len();
        
        if self.project_exists() {
            stats.has_project_file = true;
            
            // Try to read project and get language count
            if let Ok(project) = self.read_project() {
                stats.total_languages = 1 + project.project.languages.targets.len(); // source + targets
                stats.total_project_todos = project.todos.len();
            }
        }
        
        // Count translation units and todos across all chapters
        for (number, slug, _) in chapters {
            if let Ok(chapter) = self.read_chapter(number, &slug) {
                stats.total_translation_units += chapter.units.len();
                stats.total_chapter_todos += chapter.todos.len();
                
                // Count translations per language
                for unit in &chapter.units {
                    stats.total_translations += unit.translations.len();
                }
            }
        }
        
        Ok(stats)
    }
}

/// Validation report for TOML files
#[derive(Debug, Default)]
pub struct ValidationReport {
    pub valid_files: usize,
    pub invalid_files: usize,
    pub errors: Vec<String>,
    pub warnings: Vec<String>,
}

impl ValidationReport {
    pub fn new() -> Self {
        Self::default()
    }
    
    pub fn is_valid(&self) -> bool {
        self.invalid_files == 0 && self.errors.is_empty()
    }
    
    pub fn total_files(&self) -> usize {
        self.valid_files + self.invalid_files
    }
}

/// Statistics about the project's TOML files
#[derive(Debug, Default)]
pub struct ProjectStatistics {
    pub has_project_file: bool,
    pub total_chapters: usize,
    pub total_languages: usize,
    pub total_translation_units: usize,
    pub total_translations: usize,
    pub total_project_todos: usize,
    pub total_chapter_todos: usize,
}

impl ProjectStatistics {
    pub fn total_todos(&self) -> usize {
        self.total_project_todos + self.total_chapter_todos
    }
}

/// Utility functions for TOML serialization
pub mod utils {
    use super::*;
    use std::collections::HashMap;
    
    /// Pretty-print a TOML value with custom formatting
    pub fn format_toml_pretty(data: &impl serde::Serialize) -> Result<String> {
        let toml_content = toml::to_string_pretty(data)?;
        
        // Post-process for better formatting
        let formatted = toml_content
            .lines()
            .map(|line| {
                // Add extra spacing around section headers
                if line.starts_with('[') && !line.starts_with("[[") {
                    format!("\n{line}")
                } else {
                    line.to_string()
                }
            })
            .collect::<Vec<_>>()
            .join("\n");
        
        Ok(formatted)
    }
    
    /// Convert a HashMap to a TOML inline table format
    pub fn hashmap_to_inline_table<K, V>(map: &HashMap<K, V>) -> String 
    where 
        K: std::fmt::Display,
        V: std::fmt::Display,
    {
        let entries: Vec<String> = map.iter()
            .map(|(k, v)| format!("{k} = \"{v}\""))
            .collect();
        
        format!("{{ {} }}", entries.join(", "))
    }
    
    /// Validate TOML content without deserializing to a specific type
    pub fn validate_toml_syntax(content: &str) -> Result<()> {
        toml::from_str::<toml::Value>(content)?;
        Ok(())
    }
    
    /// Extract metadata from TOML file header comments
    pub fn extract_metadata_from_comments(content: &str) -> HashMap<String, String> {
        let mut metadata = HashMap::new();
        
        for line in content.lines() {
            let line = line.trim();
            if line.starts_with('#') {
                let comment = line.trim_start_matches('#').trim();
                if let Some((key, value)) = comment.split_once(':') {
                    metadata.insert(
                        key.trim().to_lowercase().replace(' ', "_"),
                        value.trim().to_string()
                    );
                }
            } else if !line.is_empty() {
                // Stop at first non-comment, non-empty line
                break;
            }
        }
        
        metadata
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::collections::HashMap;
    use crate::git_integration::toml_data::*;
    
    fn create_test_project() -> ProjectData {
        ProjectData::new(
            "test-project".to_string(),
            "Test Project".to_string(),
            "A test project for unit testing".to_string(),
            "en".to_string(),
            vec!["de".to_string(), "fr".to_string()],
            "test-editor".to_string(),
        )
    }
    
    fn create_test_chapter() -> ChapterData {
        let mut titles = HashMap::new();
        titles.insert("en".to_string(), "Test Chapter".to_string());
        titles.insert("de".to_string(), "Test Kapitel".to_string());
        
        ChapterData::new(1, "test-chapter".to_string(), titles, "en".to_string())
    }
    
    #[test]
    fn test_directory_initialization() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TomlFileManager::new(temp_dir.path());
        
        manager.init_directories().unwrap();
        
        assert!(manager.content_dir_path().exists());
        assert!(manager.chapters_dir_path().exists());
        assert!(manager.chapters_dir_path().join(".gitkeep").exists());
    }
    
    #[test]
    fn test_project_write_and_read() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TomlFileManager::new(temp_dir.path());
        manager.init_directories().unwrap();
        
        let project = create_test_project();
        
        // Write project
        manager.write_project(&project).unwrap();
        assert!(manager.project_exists());
        
        // Read project back
        let loaded_project = manager.read_project().unwrap();
        assert_eq!(loaded_project.project.id, project.project.id);
        assert_eq!(loaded_project.project.name, project.project.name);
        assert_eq!(loaded_project.project.languages.source, project.project.languages.source);
    }
    
    #[test]
    fn test_chapter_write_and_read() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TomlFileManager::new(temp_dir.path());
        manager.init_directories().unwrap();
        
        let chapter = create_test_chapter();
        
        // Write chapter
        manager.write_chapter(&chapter).unwrap();
        assert!(manager.chapter_exists(1, "test-chapter"));
        
        // Read chapter back
        let loaded_chapter = manager.read_chapter(1, "test-chapter").unwrap();
        assert_eq!(loaded_chapter.chapter.number, chapter.chapter.number);
        assert_eq!(loaded_chapter.chapter.slug, chapter.chapter.slug);
        assert_eq!(loaded_chapter.chapter.title, chapter.chapter.title);
    }
    
    #[test]
    fn test_list_chapters() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TomlFileManager::new(temp_dir.path());
        manager.init_directories().unwrap();
        
        // Create multiple chapters
        let chapter1 = create_test_chapter();
        let mut chapter2 = create_test_chapter();
        chapter2.chapter.number = 2;
        chapter2.chapter.slug = "second-chapter".to_string();
        
        manager.write_chapter(&chapter1).unwrap();
        manager.write_chapter(&chapter2).unwrap();
        
        let chapters = manager.list_chapters().unwrap();
        assert_eq!(chapters.len(), 2);
        
        // Should be sorted by number
        assert_eq!(chapters[0].0, 1);
        assert_eq!(chapters[1].0, 2);
        assert_eq!(chapters[0].1, "test-chapter");
        assert_eq!(chapters[1].1, "second-chapter");
    }
    
    #[test]
    fn test_validation() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TomlFileManager::new(temp_dir.path());
        manager.init_directories().unwrap();
        
        // Write valid files
        let project = create_test_project();
        let chapter = create_test_chapter();
        
        manager.write_project(&project).unwrap();
        manager.write_chapter(&chapter).unwrap();
        
        let report = manager.validate_all().unwrap();
        assert!(report.is_valid());
        assert_eq!(report.valid_files, 2);
        assert_eq!(report.invalid_files, 0);
    }
    
    #[test]
    fn test_statistics() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TomlFileManager::new(temp_dir.path());
        manager.init_directories().unwrap();
        
        let project = create_test_project();
        let mut chapter = create_test_chapter();
        
        // Add some translation units
        let unit1 = TranslationUnit::new(
            "unit-1".to_string(),
            1,
            "en".to_string(),
            "Test text".to_string(),
            ComplexityLevel::Low,
        );
        chapter.add_unit(unit1);
        
        manager.write_project(&project).unwrap();
        manager.write_chapter(&chapter).unwrap();
        
        let stats = manager.get_statistics().unwrap();
        assert!(stats.has_project_file);
        assert_eq!(stats.total_chapters, 1);
        assert_eq!(stats.total_languages, 3); // en + de + fr
        assert_eq!(stats.total_translation_units, 1);
    }
    
    #[test]
    fn test_backup_and_restore() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TomlFileManager::new(temp_dir.path());
        manager.init_directories().unwrap();
        
        let project = create_test_project();
        manager.write_project(&project).unwrap();
        
        let project_path = manager.project_toml_path();
        let backup_path = manager.backup_file(&project_path).unwrap();
        
        assert!(backup_path.exists());
        
        // Modify original file
        fs::write(&project_path, "# Modified").unwrap();
        
        // Restore from backup
        manager.restore_from_backup(&backup_path, &project_path).unwrap();
        
        // Should be able to read project again
        let restored_project = manager.read_project().unwrap();
        assert_eq!(restored_project.project.id, project.project.id);
    }
    
    #[test]
    fn test_toml_formatting_utils() {
        use crate::git_integration::toml_io::utils::*;
        
        let project = create_test_project();
        let formatted = format_toml_pretty(&project).unwrap();
        
        // Should contain section headers
        assert!(formatted.contains("[project]"));
        assert!(formatted.contains("[project.languages]"));
        
        // Should be valid TOML
        validate_toml_syntax(&formatted).unwrap();
    }
    
    #[test]
    fn test_metadata_extraction() {
        use crate::git_integration::toml_io::utils::*;
        
        let content = r#"# Generated at: 2025-01-02 15:30:00
# Project: Test Project
# Version: 1.0.0

[project]
name = "test"
"#;
        
        let metadata = extract_metadata_from_comments(content);
        assert_eq!(metadata.get("generated_at"), Some(&"2025-01-02 15:30:00".to_string()));
        assert_eq!(metadata.get("project"), Some(&"Test Project".to_string()));
        assert_eq!(metadata.get("version"), Some(&"1.0.0".to_string()));
    }
}