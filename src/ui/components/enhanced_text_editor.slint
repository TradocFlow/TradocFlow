import { Colors } from "../styles/colors.slint";
import { Theme } from "../styles/default.slint";
import { ScrollView, TextEdit } from "std-widgets.slint";
import { TermHighlight } from "./terminology_panel.slint";

// Text manipulation operations for enhanced editing
export struct TextOperation {
    operation_type: string, // "insert", "replace", "delete", "format"
    content: string,
    start_pos: int,
    end_pos: int,
    format_type: string, // "bold", "italic", "underline", "heading1", etc.
}

// Text selection information
export struct TextSelection {
    start: int,
    end: int,
    selected_text: string,
}

// Language item structure
struct LanguageItem {
    code: string,
    name: string,
    flag: string,
}

// Enhanced toolbar button component with accessibility
component ToolbarButton inherits Rectangle {
    in property <string> text;
    in property <string> tooltip;
    in property <int> font-weight: 400;
    in property <bool> active: false;
    in property <bool> disabled: false;
    
    callback clicked();
    callback focus-gained();
    callback focus-lost();
    
    width: 32px;
    height: 28px;
    border-radius: Theme.border-radius-sm;
    
    states [
        disabled when root.disabled: {
            background: Colors.surface;
            opacity: 0.5;
        }
        active when root.active: {
            background: Colors.primary-light;
            border-width: 1px;
            border-color: Colors.primary;
        }
        hover when touch-area.has-hover && !root.disabled: {
            background: Colors.surface-hover;
        }
        pressed when touch-area.pressed && !root.disabled: {
            background: Colors.primary-light;
        }
        // Focus state would be managed by Rust backend
    ]
    
    touch-area := TouchArea {
        enabled: !root.disabled;
        clicked => { 
            if (!root.disabled) {
                root.clicked(); 
            }
        }
        
        // Focus and keyboard handling would be implemented in Rust backend
    }
    
    Text {
        text: root.text;
        font-size: Theme.font-size-base;
        font-weight: root.font-weight;
        color: root.disabled ? Colors.text-muted : Colors.text-primary;
        horizontal-alignment: center;
        vertical-alignment: center;
        accessible-role: AccessibleRole.button;
        accessible-label: root.tooltip;
    }
}

// Language dropdown component
component LanguageDropdown inherits Rectangle {
    in property <[LanguageItem]> languages: [
        { code: "en", name: "English", flag: "ðŸ‡ºðŸ‡¸" },
        { code: "de", name: "Deutsch", flag: "ðŸ‡©ðŸ‡ª" },
        { code: "fr", name: "FranÃ§ais", flag: "ðŸ‡«ðŸ‡·" },
        { code: "es", name: "EspaÃ±ol", flag: "ðŸ‡ªðŸ‡¸" },
        { code: "it", name: "Italiano", flag: "ðŸ‡®ðŸ‡¹" },
        { code: "nl", name: "Nederlands", flag: "ðŸ‡³ðŸ‡±" }
    ];
    in property <bool> show-dropdown: false;
    callback language-selected(string);
    
    width: 140px;
    height: languages.length * 32px + 8px;
    z: 1000;
    
    if root.show-dropdown: Rectangle {
        background: Colors.surface;
        border-width: 1px;
        border-color: Colors.border;
        border-radius: Theme.border-radius-sm;
        drop-shadow-blur: 8px;
        drop-shadow-color: #00000040;
        
        VerticalLayout {
            padding: 4px;
            
            for lang[index] in root.languages: TouchArea {
                height: 32px;
                
                clicked => {
                    root.language-selected(lang.code);
                }
                
                Rectangle {
                    background: parent.has-hover ? Colors.surface-hover : transparent;
                    border-radius: Theme.border-radius-sm;
                    
                    HorizontalLayout {
                        padding-left: 12px;
                        padding-right: 12px;
                        spacing: 8px;
                        alignment: start;
                        
                        Text {
                            text: lang.flag;
                            font-size: Theme.font-size-base;
                            vertical-alignment: center;
                        }
                        
                        Text {
                            text: lang.name;
                            font-size: Theme.font-size-small;
                            color: Colors.text-primary;
                            vertical-alignment: center;
                        }
                        
                        Text {
                            text: "(" + lang.code.to-uppercase() + ")";
                            font-size: Theme.font-size-small;
                            color: Colors.text-muted;
                            vertical-alignment: center;
                        }
                    }
                }
            }
        }
    }
}

// Language selector component
component LanguageSelector inherits Rectangle {
    in property <string> current-language: "en";
    
    callback language-selected(string);
    
    property <bool> is-open: false;
    property <LanguageItem> current-lang-info: {
        if (root.current-language == "en") { { code: "en", name: "English", flag: "ðŸ‡ºðŸ‡¸" } }
        else if (root.current-language == "de") { { code: "de", name: "Deutsch", flag: "ðŸ‡©ðŸ‡ª" } }
        else if (root.current-language == "fr") { { code: "fr", name: "FranÃ§ais", flag: "ðŸ‡«ðŸ‡·" } }
        else if (root.current-language == "es") { { code: "es", name: "EspaÃ±ol", flag: "ðŸ‡ªðŸ‡¸" } }
        else if (root.current-language == "it") { { code: "it", name: "Italiano", flag: "ðŸ‡®ðŸ‡¹" } }
        else if (root.current-language == "nl") { { code: "nl", name: "Nederlands", flag: "ðŸ‡³ðŸ‡±" } }
        else { { code: "en", name: "English", flag: "ðŸ‡ºðŸ‡¸" } }
    };
    
    width: 100px;
    height: 28px;
    border-width: 1px;
    border-color: Colors.border;
    border-radius: Theme.border-radius-sm;
    background: Colors.background;
    
    states [
        hover when touch-area.has-hover: {
            border-color: Colors.border-active;
            background: Colors.surface-hover;
        }
        open when root.is-open: {
            border-color: Colors.primary;
            background: Colors.surface;
        }
    ]
    
    touch-area := TouchArea {
        clicked => {
            root.is-open = !root.is-open;
        }
    }
    
    HorizontalLayout {
        padding-left: Theme.spacing-sm;
        padding-right: Theme.spacing-sm;
        alignment: space-between;
        
        HorizontalLayout {
            spacing: 4px;
            alignment: start;
            
            Text {
                text: root.current-lang-info.flag;
                font-size: Theme.font-size-small;
                vertical-alignment: center;
            }
            
            Text {
                text: root.current-language.to-uppercase();
                font-size: Theme.font-size-small;
                color: Colors.text-primary;
                vertical-alignment: center;
            }
        }
        
        Text {
            text: root.is-open ? "â–²" : "â–¼";
            font-size: Theme.font-size-small;
            color: Colors.text-muted;
            vertical-alignment: center;
        }
    }
    
    dropdown := LanguageDropdown {
        show-dropdown: root.is-open;
        x: 0;
        y: root.height + 2px;
        
        language-selected(code) => {
            root.language-selected(code);
            root.is-open = false;
        }
    }
}

// Enhanced text editor component with professional editing capabilities
export component EnhancedTextEditor inherits Rectangle {
    in property <string> content: "";
    in property <bool> read-only: false;
    in property <string> placeholder: "Start typing...";
    in property <string> editor-mode: "markdown"; // "markdown" or "presentation"
    in property <[TermHighlight]> term-highlights: [];
    in property <bool> highlighting-enabled: true;
    
    // Enhanced selection and cursor properties
    in-out property <int> cursor-position: 0;
    in-out property <TextSelection> selection: { start: 0, end: 0, selected_text: "" };
    
    // Markdown-specific properties
    in property <bool> auto-list-continuation: true;
    in property <bool> smart-quotes: true;
    in property <bool> auto-link-detection: true;
    in property <bool> live-preview: false;
    
    // Performance and UX properties
    in property <int> undo-history-size: 50;
    in property <bool> auto-save: false;
    in property <duration> auto-save-interval: 30s;
    
    // Callbacks for text operations
    callback text-changed(string);
    callback selection-changed(TextSelection);
    callback cursor-moved(int);
    callback text-operation(TextOperation);
    callback term-highlight-clicked(TermHighlight);
    
    // Accessibility callbacks
    callback focus-gained();
    callback focus-lost();
    callback screen-reader-announce(string);
    
    // Enhanced formatting callbacks with context
    callback format-text(string, int, int); // format_type, start, end
    callback insert-text-at-cursor(string);
    callback replace-selection(string);
    callback delete-selection();
    
    // Smart editing callbacks
    callback auto-complete-triggered(string /* context */);
    callback link-detected(string /* url */, int /* position */);
    callback markdown-syntax-help-requested();
    callback live-preview-toggled(bool);
    
    // Undo/Redo callbacks
    callback undo();
    callback redo();
    
    background: Colors.editor-background;
    
    ScrollView {
        text-edit := TextEdit {
            text: root.content;
            font-size: Theme.font-size-base;
            wrap: word-wrap;
            read-only: root.read-only;
            horizontal-alignment: left;
            
            edited(text) => {
                root.text-changed(text);
                
                // Enhanced text processing
                if (root.auto-link-detection) {
                    // Detect URLs and trigger link detection callback
                    // This would be implemented in the backend
                }
                
                if (root.auto-save && text != root.content) {
                    // Trigger auto-save after delay
                }
                
                if (root.live-preview) {
                    // Trigger live preview update
                }
            }
            
            // Focus and cursor tracking would be implemented in Rust backend
            // Enhanced accessibility features would be handled there
            
            // Enhanced keyboard handling with comprehensive markdown shortcuts
            key-pressed(event) => {
                if (event.modifiers.control) {
                    if (event.text == "z" && !event.modifiers.shift) {
                        root.undo();
                        return accept;
                    } else if (event.text == "y" || (event.modifiers.shift && event.text == "z")) {
                        root.redo();
                        return accept;
                    } else if (event.text == "a") {
                        // Select all - would need to be implemented in Rust
                        return accept;
                    } else if (event.text == "b") {
                        root.format-text("bold", 0, 0);
                        return accept;
                    } else if (event.text == "i") {
                        root.format-text("italic", 0, 0);
                        return accept;
                    } else if (event.text == "u" && root.editor-mode == "presentation") {
                        root.format-text("underline", 0, 0);
                        return accept;
                    } else if (event.text == "k") {
                        root.insert-text-at-cursor("[]()");
                        return accept;
                    } else if (event.text == "e") {
                        root.format-text("code", 0, 0);
                        return accept;
                    } else if (event.text == "d") {
                        // Duplicate line
                        return accept;
                    } else if (event.text == "/") {
                        // Toggle comment/uncomment
                        return accept;
                    }
                } else if (event.modifiers.alt) {
                    if (event.text == Key.UpArrow) {
                        // Move line up
                        return accept;
                    } else if (event.text == Key.DownArrow) {
                        // Move line down
                        return accept;
                    }
                } else if (event.text == Key.Tab) {
                    if (event.modifiers.shift) {
                        root.format-text("decrease_indent", 0, 0);
                    } else {
                        root.format-text("increase_indent", 0, 0);
                    }
                    return accept;
                } else if (event.text == Key.Return && root.editor-mode == "markdown") {
                    // Smart enter for markdown lists
                    return accept;
                } else if (event.text == Key.Escape) {
                    // Clear selection or exit mode
                    return accept;
                }
                return reject;
            }
        }
        
        // Enhanced terminology highlighting overlay with better UX
        if root.highlighting-enabled && root.term-highlights.length > 0: Rectangle {
            // This overlay provides visual feedback for terminology management
            
            for highlight[index] in root.term-highlights: Rectangle {
                // Position calculated based on text metrics (simplified for demo)
                x: 10px * index; // Simplified positioning
                y: 20px * index; // Simplified positioning
                width: 100px; // Fixed width for demo
                height: 18px;
                
                // Enhanced visual styling based on highlight type
                background: highlight.highlight_type == "do_not_translate" ? Colors.warning-light :
                           highlight.highlight_type == "inconsistent" ? Colors.error-light :
                           highlight.highlight_type == "suggestion" ? Colors.info-light :
                           highlight.highlight_type == "approved" ? Colors.success-light :
                           Colors.primary-light;
                
                border-width: 1px;
                border-color: highlight.highlight_type == "do_not_translate" ? Colors.warning :
                             highlight.highlight_type == "inconsistent" ? Colors.error :
                             highlight.highlight_type == "suggestion" ? Colors.info :
                             highlight.highlight_type == "approved" ? Colors.success :
                             Colors.primary;
                
                border-radius: 3px;
                opacity: 0.4;
                
                // Enhanced interaction
                states [
                    hover when highlight-touch.has-hover: {
                        opacity: 0.6;
                        drop-shadow-blur: 2px;
                        drop-shadow-color: #00000020;
                    }
                ]
                
                highlight-touch := TouchArea {
                    clicked => {
                        root.term-highlight-clicked(highlight);
                    }
                    
                    // Tooltip on hover
                    mouse-cursor: pointer;
                }
                
                // Highlight indicator icon
                if highlight.highlight_type == "do_not_translate": Text {
                    text: "ðŸš«";
                    font-size: 10px;
                    x: parent.width - 12px;
                    y: -2px;
                }
                if highlight.highlight_type == "inconsistent": Text {
                    text: "âš ";
                    font-size: 10px;
                    x: parent.width - 12px;
                    y: -2px;
                }
                if highlight.highlight_type == "suggestion": Text {
                    text: "ðŸ’¡";
                    font-size: 10px;
                    x: parent.width - 12px;
                    y: -2px;
                }
                if highlight.highlight_type == "approved": Text {
                    text: "âœ“";
                    font-size: 10px;
                    x: parent.width - 12px;
                    y: -2px;
                }
            }
        }
    }
    
    // Enhanced visual feedback for empty editor with accessibility
    if root.content == "": Rectangle {
        x: Theme.spacing-md;
        y: Theme.spacing-md;
        
        Text {
            text: root.placeholder;
            color: Colors.text-muted;
            font-size: Theme.font-size-base;
            accessible-role: AccessibleRole.text;
            accessible-label: "Text editor placeholder: " + root.placeholder;
        }
    }
    
    // Accessibility features would be implemented in the Rust backend
}

// Enhanced toolbar with text manipulation capabilities
component EnhancedToolbar inherits Rectangle {
    in property <string> mode: "markdown";
    in property <string> language: "en";
    in property <TextSelection> selection;
    in property <bool> has-selection: selection.start != selection.end;
    
    // Language selection
    callback language-changed(string);
    
    // Text formatting callbacks
    callback format-bold();
    callback format-italic();
    callback format-underline();
    callback format-heading(int);
    callback format-code();
    callback format-quote();
    
    // List operations
    callback insert-bullet-list();
    callback insert-numbered-list();
    callback insert-checklist();
    
    // Insert operations
    callback insert-link();
    callback insert-image();
    callback insert-table();
    callback insert-code-block();
    
    // Text operations
    callback increase-indent();
    callback decrease-indent();
    callback align-left();
    callback align-center();
    callback align-right();
    
    // Undo/Redo
    callback undo();
    callback redo();
    
    background: Colors.surface;
    height: Theme.toolbar-height;
    border-width: 1px;
    border-color: Colors.border;
    
    HorizontalLayout {
        padding: Theme.spacing-sm;
        spacing: Theme.spacing-xs;
        alignment: start;
        
        // Language selector section
        LanguageSelector {
            current-language: root.language;
            
            language-selected(lang) => {
                root.language-changed(lang);
            }
        }
        
        // Separator
        Rectangle {
            width: 1px;
            height: 20px;
            background: Colors.border;
        }
        
        // Undo/Redo section
        ToolbarButton { 
            text: "â†¶"; 
            tooltip: "Undo (Ctrl+Z)"; 
            clicked => { root.undo(); }
        }
        ToolbarButton { 
            text: "â†·"; 
            tooltip: "Redo (Ctrl+Y)"; 
            clicked => { root.redo(); }
        }
        
        // Separator
        Rectangle {
            width: 1px;
            height: 20px;
            background: Colors.border;
        }
        
        // Basic formatting section with enhanced accessibility
        ToolbarButton { 
            text: "B"; 
            tooltip: "Bold (Ctrl+B)"; 
            font-weight: 700;
            active: root.has-selection;
            clicked => { root.format-bold(); }
        }
        ToolbarButton { 
            text: "I"; 
            tooltip: "Italic (Ctrl+I)"; 
            active: root.has-selection;
            clicked => { root.format-italic(); }
        }
        
        if root.mode == "presentation": ToolbarButton { 
            text: "U"; 
            tooltip: "Underline (Ctrl+U)"; 
            active: root.has-selection;
            clicked => { root.format-underline(); }
        }
        
        ToolbarButton { 
            text: "</>"; 
            tooltip: "Code (Ctrl+E)"; 
            active: root.has-selection;
            clicked => { root.format-code(); }
        }
        
        // Separator
        Rectangle {
            width: 1px;
            height: 20px;
            background: Colors.border;
        }
        
        // Heading section
        ToolbarButton { 
            text: "H1"; 
            tooltip: "Heading 1"; 
            clicked => { root.format-heading(1); }
        }
        ToolbarButton { 
            text: "H2"; 
            tooltip: "Heading 2"; 
            clicked => { root.format-heading(2); }
        }
        ToolbarButton { 
            text: "H3"; 
            tooltip: "Heading 3"; 
            clicked => { root.format-heading(3); }
        }
        
        // Separator
        Rectangle {
            width: 1px;
            height: 20px;
            background: Colors.border;
        }
        
        // List section
        ToolbarButton { 
            text: "â€¢"; 
            tooltip: "Bullet List"; 
            clicked => { root.insert-bullet-list(); }
        }
        ToolbarButton { 
            text: "1."; 
            tooltip: "Numbered List"; 
            clicked => { root.insert-numbered-list(); }
        }
        ToolbarButton { 
            text: "â˜‘"; 
            tooltip: "Checklist"; 
            clicked => { root.insert-checklist(); }
        }
        
        // Separator
        Rectangle {
            width: 1px;
            height: 20px;
            background: Colors.border;
        }
        
        // Insert section
        ToolbarButton { 
            text: "ðŸ”—"; 
            tooltip: "Insert Link (Ctrl+K)"; 
            clicked => { root.insert-link(); }
        }
        ToolbarButton { 
            text: "ðŸ–¼"; 
            tooltip: "Insert Image"; 
            clicked => { root.insert-image(); }
        }
        ToolbarButton { 
            text: "âŠž"; 
            tooltip: "Insert Table"; 
            clicked => { root.insert-table(); }
        }
        
        if root.mode == "markdown": ToolbarButton { 
            text: "{}"; 
            tooltip: "Code Block"; 
            clicked => { root.insert-code-block(); }
        }
        
        // Separator
        Rectangle {
            width: 1px;
            height: 20px;
            background: Colors.border;
        }
        
        // Quote button for markdown
        if root.mode == "markdown": ToolbarButton { 
            text: "\""; 
            tooltip: "Quote Block"; 
            clicked => { root.format-quote(); }
        }
        
        // Indentation controls
        ToolbarButton { 
            text: "â‡¤"; 
            tooltip: "Decrease Indent"; 
            clicked => { root.decrease-indent(); }
        }
        ToolbarButton { 
            text: "â‡¥"; 
            tooltip: "Increase Indent"; 
            clicked => { root.increase-indent(); }
        }
        
        // Alignment controls for presentation mode
        if root.mode == "presentation": Rectangle {
            width: 1px;
            height: 20px;
            background: Colors.border;
        }
        
        if root.mode == "presentation": ToolbarButton { 
            text: "â«·"; 
            tooltip: "Align Left"; 
            clicked => { root.align-left(); }
        }
        if root.mode == "presentation": ToolbarButton { 
            text: "â«¸"; 
            tooltip: "Align Center"; 
            clicked => { root.align-center(); }
        }
        if root.mode == "presentation": ToolbarButton { 
            text: "â«¹"; 
            tooltip: "Align Right"; 
            clicked => { root.align-right(); }
        }
    }
}

// Complete enhanced editor component combining toolbar and text editor
export component ProfessionalEditor inherits Rectangle {
    in property <string> content: "";
    in property <string> mode: "markdown"; // "markdown" or "presentation"  
    in property <string> language: "en";
    in property <bool> read-only: false;
    in property <[TermHighlight]> term-highlights: [];
    in property <bool> highlighting-enabled: true;
    
    // Text operation callbacks
    callback content-changed(string);
    callback language-changed(string);
    callback text-operation(TextOperation);
    callback term-highlight-clicked(TermHighlight);
    
    // Formatting callbacks
    callback format-bold();
    callback format-italic();
    callback format-underline();
    callback format-heading(int);
    callback format-code();
    callback format-quote();
    
    // List callbacks
    callback insert-bullet-list();
    callback insert-numbered-list();
    callback insert-checklist();
    
    // Insert callbacks
    callback insert-link();
    callback insert-image();
    callback insert-table();
    callback insert-code-block();
    
    // Text manipulation callbacks
    callback increase-indent();
    callback decrease-indent();
    callback align-left();
    callback align-center();
    callback align-right();
    
    // Undo/Redo callbacks
    callback undo();
    callback redo();
    
    background: Colors.editor-background;
    
    VerticalLayout {
        spacing: 0px;
        
        // Enhanced toolbar
        toolbar := EnhancedToolbar {
            mode: root.mode;
            language: root.language;
            
            language-changed(lang) => { root.language-changed(lang); }
            
            // Format callbacks
            format-bold => { root.format-bold(); }
            format-italic => { root.format-italic(); }
            format-underline => { root.format-underline(); }
            format-heading(level) => { root.format-heading(level); }
            format-code => { root.format-code(); }
            format-quote => { root.format-quote(); }
            
            // List callbacks
            insert-bullet-list => { root.insert-bullet-list(); }
            insert-numbered-list => { root.insert-numbered-list(); }
            insert-checklist => { root.insert-checklist(); }
            
            // Insert callbacks
            insert-link => { root.insert-link(); }
            insert-image => { root.insert-image(); }
            insert-table => { root.insert-table(); }
            insert-code-block => { root.insert-code-block(); }
            
            // Text manipulation callbacks
            increase-indent => { root.increase-indent(); }
            decrease-indent => { root.decrease-indent(); }
            align-left => { root.align-left(); }
            align-center => { root.align-center(); }
            align-right => { root.align-right(); }
            
            // Undo/Redo callbacks
            undo => { root.undo(); }
            redo => { root.redo(); }
        }
        
        // Enhanced text editor
        text-editor := EnhancedTextEditor {
            content: root.content;
            read-only: root.read-only;
            editor-mode: root.mode;
            term-highlights: root.term-highlights;
            highlighting-enabled: root.highlighting-enabled;
            placeholder: root.mode == "markdown" ? 
                "Start writing in Markdown..." : 
                "Start writing your presentation...";
            
            text-changed(text) => {
                root.content-changed(text);
            }
            
            text-operation(op) => {
                root.text-operation(op);
            }
            
            term-highlight-clicked(highlight) => {
                root.term-highlight-clicked(highlight);
            }
            
            undo => { root.undo(); }
            redo => { root.redo(); }
        }
    }
}